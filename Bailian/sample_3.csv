commit_id,cve,cwe,filepath,func_body,func_name,function,is_vulnerable,line_statements,project,project_repo_path,statements
7135ec229882370a00411aa50030eada6034cc1b,['CVE-2014-6229'],['CWE-200'],hphp/runtime/ext/ext_hash.cpp,"  explicit HashContext(const HashContext* ctx) {\n    assert(ctx->ops);\n    assert(ctx->ops->context_size >= 0);\n    ops = ctx->ops;\n    context = malloc(ops->context_size);\n    ops->hash_copy(context, ctx->context);\n    options = ctx->options;\n    key = ctx->key ? strdup(ctx->key) : nullptr;\n  }",HPHP::HashContext::HashContext,"{'CWE-200': '  explicit HashContext(const HashContext* ctx) {\n    assert(ctx->ops);\n    assert(ctx->ops->context_size >= 0);\n    ops = ctx->ops;\n    context = malloc(ops->context_size);\n    ops->hash_copy(context, ctx->context);\n    options = ctx->options;\n    key = ctx->key ? strdup(ctx->key) : nullptr;\n  }'}",TRUE,"[[155, '    key = ctx->key ? strdup(ctx->key) : nullptr;']]",hhvm,symbol_backend_projects/hhvm,"[[155, 'key = ctx->key ? strdup(ctx->key) : nullptr;']]"
0b932d4b926d46ac5060f02617330dc444e06da1,['CVE-2016-4992'],['CWE-200'],ldap/servers/slapd/back-ldbm/dn2entry.c,"dn2ancestor(\n    Slapi_Backend *be,\n    const Slapi_DN	*sdn,\n	Slapi_DN *ancestordn,\n    back_txn		*txn,\n    int			*err\n)\n{\n	struct backentry *e = NULL;\n\n	LDAPDebug( LDAP_DEBUG_TRACE, ""=> dn2ancestor \""%s\""\n"", slapi_sdn_get_dn(sdn), 0, 0 );\n\n    /* first, check to see if the given sdn is empty or a root suffix of the\n       given backend - if so, it has no parent */\n    if (!slapi_sdn_isempty(sdn) && !slapi_be_issuffix( be, sdn )) {\n        Slapi_DN ancestorndn;\n        const char *ptr;\n\n        /* assign ancestordn to the parent of the given dn */\n        ptr = slapi_dn_find_parent(slapi_sdn_get_dn(sdn));\n        /* assign the ancestordn dn pointer to the parent of dn from sdn - sdn ""owns""\n           the memory, but ancestordn points to it */\n        slapi_sdn_set_normdn_byref(ancestordn, ptr); /* free any previous contents */\n        /* now, do the same for the normalized version */\n        /* ancestorndn holds the normalized version for iteration purposes and\n           because dn2entry needs the normalized dn */\n        ptr = slapi_dn_find_parent(slapi_sdn_get_ndn(sdn));\n        slapi_sdn_init_ndn_byref(&ancestorndn, ptr);\n\n        /*\n          At this point you may be wondering why I need both ancestorndn and\n          ancestordn.  Because, with the slapi_sdn interface, you cannot set both\n          the dn and ndn byref at the same time.  Whenever you call set_dn or set_ndn,\n          it calls slapi_sdn_done which wipes out the previous contents.  I suppose I\n          could have added another API to allow you to pass them both in.  Also, using\n          slapi_sdn_get_ndn(ancestordn) every time would result in making a copy then\n          normalizing the copy every time - not efficient.\n          So, why not just use a char* for the ancestorndn?  Because dn2entry requires\n          a Slapi_DN with the normalized dn.\n        */\n\n        /* stop when we get to """", or a backend suffix point */\n        while (!e && !slapi_sdn_isempty(&ancestorndn) && !slapi_be_issuffix( be, &ancestorndn )) {\n            /* find the entry - it uses the ndn, so no further conversion is necessary */\n            e= dn2entry(be,&ancestorndn,txn,err);\n            if (!e) {\n                /* not found, so set ancestordn to its parent and try again */\n                ptr = slapi_dn_find_parent(slapi_sdn_get_ndn(&ancestorndn));\n                /* keep in mind that ptr points to the raw ndn pointer inside\n                   ancestorndn which is still the ndn string ""owned"" by sdn, the\n                   original dn we started with - we are careful not to touch\n                   or change it */\n                slapi_sdn_set_ndn_byref(&ancestorndn, ptr); /* wipe out the previous contents */\n                /* now do the same for the unnormalized one */\n                ptr = slapi_dn_find_parent(slapi_sdn_get_dn(ancestordn));\n                slapi_sdn_set_normdn_byref(ancestordn, ptr); /* wipe out the previous contents */\n            }\n        }\n\n        slapi_sdn_done(&ancestorndn);\n    }\n\n    /* post conditions:\n       e is the entry of the ancestor of sdn OR e is the suffix entry\n       OR e is NULL\n       ancestordn contains the unnormalized DN of e or is empty */\n    LDAPDebug( LDAP_DEBUG_TRACE, ""<= dn2ancestor %p\n"", e, 0, 0 );\n    return( e );\n}",dn2ancestor,"{'CWE-200': 'dn2ancestor(\n    Slapi_Backend *be,\n    const Slapi_DN\t*sdn,\n\tSlapi_DN *ancestordn,\n    back_txn\t\t*txn,\n    int\t\t\t*err\n)\n{\n\tstruct backentry *e = NULL;\n\n\tLDAPDebug( LDAP_DEBUG_TRACE, ""=> dn2ancestor \\""%s\\""\\n"", slapi_sdn_get_dn(sdn), 0, 0 );\n\n    /* first, check to see if the given sdn is empty or a root suffix of the\n       given backend - if so, it has no parent */\n    if (!slapi_sdn_isempty(sdn) && !slapi_be_issuffix( be, sdn )) {\n        Slapi_DN ancestorndn;\n        const char *ptr;\n\n        /* assign ancestordn to the parent of the given dn */\n        ptr = slapi_dn_find_parent(slapi_sdn_get_dn(sdn));\n        /* assign the ancestordn dn pointer to the parent of dn from sdn - sdn ""owns""\n           the memory, but ancestordn points to it */\n        slapi_sdn_set_normdn_byref(ancestordn, ptr); /* free any previous contents */\n        /* now, do the same for the normalized version */\n        /* ancestorndn holds the normalized version for iteration purposes and\n           because dn2entry needs the normalized dn */\n        ptr = slapi_dn_find_parent(slapi_sdn_get_ndn(sdn));\n        slapi_sdn_init_ndn_byref(&ancestorndn, ptr);\n\n        /*\n          At this point you may be wondering why I need both ancestorndn and\n          ancestordn.  Because, with the slapi_sdn interface, you cannot set both\n          the dn and ndn byref at the same time.  Whenever you call set_dn or set_ndn,\n          it calls slapi_sdn_done which wipes out the previous contents.  I suppose I\n          could have added another API to allow you to pass them both in.  Also, using\n          slapi_sdn_get_ndn(ancestordn) every time would result in making a copy then\n          normalizing the copy every time - not efficient.\n          So, why not just use a char* for the ancestorndn?  Because dn2entry requires\n          a Slapi_DN with the normalized dn.\n        */\n\n        /* stop when we get to """", or a backend suffix point */\n        while (!e && !slapi_sdn_isempty(&ancestorndn) && !slapi_be_issuffix( be, &ancestorndn )) {\n            /* find the entry - it uses the ndn, so no further conversion is necessary */\n            e= dn2entry(be,&ancestorndn,txn,err);\n            if (!e) {\n                /* not found, so set ancestordn to its parent and try again */\n                ptr = slapi_dn_find_parent(slapi_sdn_get_ndn(&ancestorndn));\n                /* keep in mind that ptr points to the raw ndn pointer inside\n                   ancestorndn which is still the ndn string ""owned"" by sdn, the\n                   original dn we started with - we are careful not to touch\n                   or change it */\n                slapi_sdn_set_ndn_byref(&ancestorndn, ptr); /* wipe out the previous contents */\n                /* now do the same for the unnormalized one */\n                ptr = slapi_dn_find_parent(slapi_sdn_get_dn(ancestordn));\n                slapi_sdn_set_normdn_byref(ancestordn, ptr); /* wipe out the previous contents */\n            }\n        }\n\n        slapi_sdn_done(&ancestorndn);\n    }\n\n    /* post conditions:\n       e is the entry of the ancestor of sdn OR e is the suffix entry\n       OR e is NULL\n       ancestordn contains the unnormalized DN of e or is empty */\n    LDAPDebug( LDAP_DEBUG_TRACE, ""<= dn2ancestor %p\\n"", e, 0, 0 );\n    return( e );\n}'}",TRUE,"[[154, '\tSlapi_DN *ancestordn,'], [156, '    int\t\t\t*err'], [159, '\tstruct backentry *e = NULL;'], [161, '\tLDAPDebug( LDAP_DEBUG_TRACE, ""=> dn2ancestor \\""%s\\""\\n"", slapi_sdn_get_dn(sdn), 0, 0 );'], [193, '        while (!e && !slapi_sdn_isempty(&ancestorndn) && !slapi_be_issuffix( be, &ancestorndn )) {']]",389-ds-base,symbol_backend_projects/389-ds-base,"[[151, 'dn2ancestor(\n    Slapi_Backend *be,\n    const Slapi_DN\t*sdn,\n\tSlapi_DN *ancestordn,\n    back_txn\t\t*txn,\n    int\t\t\t*err\n)'], [156, 'int\t\t\t*err'], [159, 'struct backentry *e = NULL;'], [161, 'LDAPDebug( LDAP_DEBUG_TRACE, ""=> dn2ancestor \\""%s\\""\\n"", slapi_sdn_get_dn(sdn), 0, 0 );'], [193, 'while (!e && !slapi_sdn_isempty(&ancestorndn) && !slapi_be_issuffix( be, &ancestorndn )) {']]"
